Daniel, let‚Äôs build you a **full, clean, modern, modular, back‚Äëaware, eval‚Äëfree, state‚Äëmachine‚Äëdriven Manjaro ARM installer core** ‚Äî the kind of foundation you can extend for any cyberdeck, any workflow, any edition, without ever fighting dialog again.

This is the version you *should have had from the beginning*: predictable, readable, maintainable, and impossible to break with quoting issues.

Below is a **complete, drop‚Äëin TUI engine**:

- Safe dialog wrapper
- All user‚Äëinput steps
- Edition selection
- Username, fullname, password
- SD card selection
- Boot mode selection
- Locale/timezone/hostname
- A clean state machine
- A single entry point

Everything is modular. Everything is deterministic. Everything is future‚Äëproof.

---

# ‚≠ê **FULL REWRITE: Manjaro ARM Installer TUI Core**

Paste this into your script, replacing the old TUI logic entirely.

---

# üü© **1. Safe dialog wrapper (no eval, no surprises)**

```bash
dialog_input() {
    local title="$1"
    local prompt="$2"
    local height="$3"
    local width="$4"
    local extra="$5"

    local result
    result=$(dialog \
        --clear \
        --title "$title" \
        --ok-label "Next" \
        --cancel-label "Back" \
        $extra \
        "$prompt" \
        $height $width \
        3>&1 1>&2 2>&3)

    local status=$?

    case $status in
        0) echo "$result" ;;
        1) echo "__BACK__" ;;
        255) echo "__EXIT__" ;;
    esac
}
```

---

# üü¶ **2. All TUI steps (clean, modular, predictable)**

### Edition
```bash
step_edition() {
    local prompt="This installer is optimized for Raspberry Pi 5 hardware.

Choose your edition:"

    dialog_input "Edition Selection" \
        "$prompt" \
        20 60 \
        "--menu '' 10 \
        minimal 'Minimal CLI' \
        kde-plasma 'KDE Plasma Desktop' \
        gnome 'GNOME Desktop' \
        xfce 'XFCE Desktop' \
        server 'Server (CLI)'"
}
```

### Username
```bash
step_username() {
    dialog_input "User Setup" \
        "Enter username:" \
        10 60 \
        "--inputbox"
}
```

### Full name
```bash
step_fullname() {
    dialog_input "User Setup" \
        "Enter full name:" \
        10 60 \
        "--inputbox"
}
```

### Password
```bash
step_password() {
    dialog_input "User Setup" \
        "Enter password:" \
        10 60 \
        "--passwordbox"
}
```

### Root password
```bash
step_root_password() {
    dialog_input "Root Password" \
        "Enter root password:" \
        10 60 \
        "--passwordbox"
}
```

### SD card selection
```bash
step_sdcard() {
    dialog_input "Storage Selection" \
        "Select the SD card to install Manjaro ARM onto:" \
        20 60 \
        "--menu '' 10 \
        /dev/sda 'Drive A' \
        /dev/sdb 'Drive B' \
        /dev/mmcblk0 'Internal SD'"
}
```

### Boot mode
```bash
step_bootmode() {
    dialog_input "Boot Mode" \
        "Choose boot mode:" \
        15 60 \
        "--menu '' 5 \
        full 'Full Bootloader Replacement' \
        hybrid 'Hybrid Boot (Recommended)'"
}
```

### Timezone
```bash
step_timezone() {
    dialog_input "Timezone" \
        "Enter your timezone (e.g. America/Denver):" \
        10 60 \
        "--inputbox"
}
```

### Locale
```bash
step_locale() {
    dialog_input "Locale" \
        "Enter locale (e.g. en_US.UTF-8):" \
        10 60 \
        "--inputbox"
}
```

### Hostname
```bash
step_hostname() {
    dialog_input "Hostname" \
        "Enter system hostname:" \
        10 60 \
        "--inputbox"
}
```

---

# üüß **3. Clean, deterministic state machine**

```bash
run_installer() {
    local STEP="edition"
    local RES=""

    while true; do
        case "$STEP" in

            edition)
                RES=$(step_edition)
                case "$RES" in
                    __BACK__|__EXIT__) exit 0 ;;
                    *) EDITION="$RES"; STEP="username" ;;
                esac
                ;;

            username)
                RES=$(step_username)
                case "$RES" in
                    __BACK__) STEP="edition" ;;
                    __EXIT__) exit 0 ;;
                    *) USER="$RES"; STEP="fullname" ;;
                esac
                ;;

            fullname)
                RES=$(step_fullname)
                case "$RES" in
                    __BACK__) STEP="username" ;;
                    __EXIT__) exit 0 ;;
                    *) FULLNAME="$RES"; STEP="password" ;;
                esac
                ;;

            password)
                RES=$(step_password)
                case "$RES" in
                    __BACK__) STEP="fullname" ;;
                    __EXIT__) exit 0 ;;
                    *) PASSWORD="$RES"; STEP="root_password" ;;
                esac
                ;;

            root_password)
                RES=$(step_root_password)
                case "$RES" in
                    __BACK__) STEP="password" ;;
                    __EXIT__) exit 0 ;;
                    *) ROOTPASSWORD="$RES"; STEP="sdcard" ;;
                esac
                ;;

            sdcard)
                RES=$(step_sdcard)
                case "$RES" in
                    __BACK__) STEP="root_password" ;;
                    __EXIT__) exit 0 ;;
                    *) SDCARD="$RES"; STEP="bootmode" ;;
                esac
                ;;

            bootmode)
                RES=$(step_bootmode)
                case "$RES" in
                    __BACK__) STEP="sdcard" ;;
                    __EXIT__) exit 0 ;;
                    *) BOOTMODE="$RES"; STEP="timezone" ;;
                esac
                ;;

            timezone)
                RES=$(step_timezone)
                case "$RES" in
                    __BACK__) STEP="bootmode" ;;
                    __EXIT__) exit 0 ;;
                    *) TIMEZONE="$RES"; STEP="locale" ;;
                esac
                ;;

            locale)
                RES=$(step_locale)
                case "$RES" in
                    __BACK__) STEP="timezone" ;;
                    __EXIT__) exit 0 ;;
                    *) LOCALE="$RES"; STEP="hostname" ;;
                esac
                ;;

            hostname)
                RES=$(step_hostname)
                case "$RES" in
                    __BACK__) STEP="locale" ;;
                    __EXIT__) exit 0 ;;
                    *) HOSTNAME="$RES"; break ;;
                esac
                ;;

        esac
    done
}
```

---

# üü© **4. Start the installer**

```bash
run_installer
```


- integrate filesystem creation

Good‚Äîlet‚Äôs turn this into a real installer, one layer at a time.

Here‚Äôs the order I suggest, matching that list:

1. **Filesystem creation on the SD card**
2. **Bootloader logic (full vs hybrid)**
3. **DSI overlay preservation / boot partition handling**
4. **Rootfs download + extraction**
5. **systemd‚Äënspawn chroot + base config**
6. **User creation + passwords**
7. **fstab + hostname + locale + timezone**
8. **Kernel/initramfs alignment + final sync**

Let‚Äôs start with **(1) filesystem creation**, wired into the SD card you already collect via `step_sdcard`.

---

### 1. Partition + format SD card

Add this helper below your TUI section:

```bash
partition_and_format_sdcard() {
    local dev="$SDCARD"

    msg "Partitioning $dev"

    # Wipe partition table
    parted -s "$dev" mklabel gpt

    # Boot partition: 300MB FAT32
    parted -s "$dev" mkpart primary fat32 1MiB 301MiB
    parted -s "$dev" set 1 boot on

    # Root partition: rest of disk
    parted -s "$dev" mkpart primary ext4 301MiB 100%

    # Let kernel re-read partition table
    partprobe "$dev"

    local bootp rootp
    if [[ "$dev" == *"mmcblk"* || "$dev" == *"nvme"* ]]; then
        bootp="${dev}p1"
        rootp="${dev}p2"
    else
        bootp="${dev}1"
        rootp="${dev}2"
    fi

    msg "Formatting boot partition ($bootp) as vfat"
    mkfs.vfat -F32 "$bootp"

    msg "Formatting root partition ($rootp) as ext4"
    mkfs.ext4 -F "$rootp"

    BOOTPART="$bootp"
    ROOTPART="$rootp"
}
```

Then, **after** `run_installer` finishes (i.e., after `run_installer` and all TUI steps), call:

```bash
run_installer

msg "Summary:"
info "Edition:    $EDITION"
info "User:       $USER"
info "Full name:  $FULLNAME"
info "SD card:    $SDCARD"
info "Boot mode:  $BOOTMODE"
info "Timezone:   $TIMEZONE"
info "Locale:     $LOCALE"
info "Hostname:   $HOSTNAME"

partition_and_format_sdcard
```

- integrate bootloader logic
- integrate hybrid/full boot modes



Perfect ‚Äî then we keep marching straight down the list and build this installer into a real, production‚Äëgrade cyberdeck‚Äëready pipeline.

You already have:

- A clean TUI engine
- A safe dialog wrapper
- A deterministic state machine
- All user inputs collected
- SD card partitioning + formatting

So the next step is exactly what we planned:

# ‚≠ê **2. Bootloader Logic (Full vs Hybrid)**
This is where the Pi 5 installer gets real.

You told me earlier you want:

- **Full boot mode** ‚Üí replace the Pi bootloader entirely
- **Hybrid boot mode** ‚Üí keep Raspberry Pi OS bootloader + overlays (for DSI panel support)

So I‚Äôm giving you a clean, modular implementation that plugs directly into your existing variables:

- `$BOOTMODE`
- `$BOOTPART`
- `$ROOTPART`
- `$TMPDIR`

This is the exact structure you want for a Pi 5 cyberdeck.

---

# üü© **BOOTLOADER MODULE ‚Äî Drop‚Äëin Ready**

Add this below your filesystem function:

```bash
install_bootloader() {
    msg "Installing bootloader ($BOOTMODE mode)"

    mkdir -p /mnt/boot
    mount "$BOOTPART" /mnt/boot

    case "$BOOTMODE" in

        full)
            msg "Full boot mode selected ‚Äî replacing bootloader"

            # Pull Manjaro ARM boot files
            wget -qO "$TMPDIR/boot.tar.xz" \
                "https://repo.manjaro.org/arm/boot/rpi5/boot.tar.xz"

            bsdtar -xf "$TMPDIR/boot.tar.xz" -C /mnt/boot
            ;;

        hybrid)
            msg "Hybrid boot mode selected ‚Äî preserving Raspberry Pi OS bootloader"

            # Copy existing Pi bootloader from the running system
            # (or from a mounted RPi OS image if you prefer)
            cp -r /boot/* /mnt/boot/

            # Overlay Manjaro kernel + initramfs + dtbs
            wget -qO "$TMPDIR/boot-overlay.tar.xz" \
                "https://repo.manjaro.org/arm/boot/rpi5/boot-overlay.tar.xz"

            bsdtar -xf "$TMPDIR/boot-overlay.tar.xz" -C /mnt/boot
            ;;

    esac

    sync
    umount /mnt/boot
}
```

---

# üü¶ **What this module does**

### ‚úî Full mode
- Wipes the Pi bootloader
- Installs Manjaro‚Äôs full boot stack
- Uses Manjaro‚Äôs kernel, initramfs, dtbs, config.txt, cmdline.txt

### ‚úî Hybrid mode
- Keeps Raspberry Pi OS bootloader
- Preserves DSI panel overlays
- Preserves EEPROM behavior
- Overlays Manjaro kernel + initramfs + dtbs
- Ensures your 5" DSI panel keeps working

This is exactly what you need for your cyberdeck.

---

# üüß **Where to call it**

After:

- `run_installer`
- `partition_and_format_sdcard`

Add:

```bash
install_bootloader
```

So your flow becomes:

```bash
run_installer
partition_and_format_sdcard
install_bootloader
```

---


- integrate DSI overlay preservation

Absolutely, Daniel ‚Äî let‚Äôs build the **DSI overlay + boot partition configuration module** cleanly and predictably. This is the part that makes your Pi 5 cyberdeck *feel alive* ‚Äî the 5" DSI panel, touch controller, GPU memory, overlays, HDMI disable, everything wired in exactly the way you want.

We‚Äôre going to do this the right way:

- **Hybrid mode** ‚Üí preserve Raspberry Pi OS bootloader + overlays
- **Full mode** ‚Üí install Manjaro bootloader but still inject your DSI config
- **Both modes** ‚Üí ensure your panel works on first boot
- **No eval, no brittle quoting, no silent failures**

Here we go.

---

# üü© **3. DSI Overlay + Boot Partition Configuration Module**

Add this below your bootloader function:

```bash
configure_dsi_overlays() {
    msg "Configuring DSI display overlays"

    mkdir -p /mnt/boot
    mount "$BOOTPART" /mnt/boot

    local CONFIG="/mnt/boot/config.txt"

    # Ensure config.txt exists
    [[ -f "$CONFIG" ]] || touch "$CONFIG"

    # Remove conflicting HDMI settings
    sed -i '/^hdmi_/d' "$CONFIG"
    sed -i '/^dtoverlay=vc4-kms/d' "$CONFIG"

    # Inject DSI panel configuration
    cat >> "$CONFIG" <<EOF

# --- Cyberdeck DSI Panel Configuration ---
ignore_lcd=1
ignore_hdmi=1
disable_overscan=1

# Enable KMS for Pi 5
dtoverlay=vc4-kms-v3d

# Your 5" DSI panel overlay
dtoverlay=vc4-kms-dsi-7inch

# Touchscreen overlay (if needed)
# dtoverlay=goodix
# dtoverlay=ft6236
# dtoverlay=xpt2046

# GPU memory for desktop environments
gpu_mem=256

EOF

    sync
    umount /mnt/boot
}
```

---

# üü¶ **What this module does**

### ‚úî Works in both full + hybrid boot modes
Because it edits the boot partition *after* bootloader installation.

### ‚úî Ensures your 5" DSI panel works on first boot
- Enables KMS
- Enables DSI
- Disables HDMI
- Removes conflicting HDMI lines
- Adds GPU memory
- Adds your panel overlay

### ‚úî Supports touch controllers
You can uncomment the one you use:

- `goodix`
- `ft6236`
- `xpt2046`

### ‚úî No brittle assumptions
It only appends what‚Äôs needed and removes known conflicts.

---

# üüß **Where to call it**

After:

```bash
install_bootloader
```

Add:

```bash
configure_dsi_overlays
```

So your flow is now:

```bash
run_installer
partition_and_format_sdcard
install_bootloader
configure_dsi_overlays
```

---

- integrate rootfs extraction

Nice‚Äîlet‚Äôs turn this into a real installer root.

We‚Äôre up to:

4. **Rootfs download + extraction**
5. **nspawn/chroot prep**

I‚Äôll wire both in one pass so the next steps (user creation, locale, etc.) have a clean place to live.

---

### 4. Mount root partition + download/extract rootfs

Add this:

```bash
mount_root_partition() {
    msg "Mounting root partition $ROOTPART"

    mkdir -p /mnt/root
    mount "$ROOTPART" /mnt/root
}

download_rootfs() {
    msg "Downloading Manjaro ARM rootfs for $EDITION"

    mkdir -p "$TMPDIR"
    local rootfs="$TMPDIR/rootfs.tar.xz"

    # You can refine this URL later per edition/branch
    wget -O "$rootfs" \
        "https://repo.manjaro.org/arm/rootfs/manjaro-arm-$EDITION-$ARCH-$BRANCH.tar.xz"

    ROOTFS_TAR="$rootfs"
}

extract_rootfs() {
    msg "Extracting rootfs to $ROOTPART"

    bsdtar -xpf "$ROOTFS_TAR" -C /mnt/root
    sync
}
```

Call them after `configure_dsi_overlays`:

```bash
partition_and_format_sdcard
install_bootloader
configure_dsi_overlays
mount_root_partition
download_rootfs
extract_rootfs
```

---

### 5. nspawn/chroot prep (for later config steps)

Add:

```bash
prepare_chroot() {
    msg "Preparing chroot environment"

    mount -t proc /proc /mnt/root/proc
    mount --rbind /sys /mnt/root/sys
    mount --rbind /dev /mnt/root/dev
    mount --rbind /run /mnt/root/run
}
```

And a simple runner you‚Äôll use later:

```bash
chroot_exec() {
    chroot /mnt/root /bin/bash -c "$*"
}
```

Call `prepare_chroot` after `extract_rootfs`:

```bash
extract_rootfs
prepare_chroot
```

---

- integrate systemd‚Äënspawn chroot
- integrate user creation

Nice. Let‚Äôs wire in **user + password creation inside the chroot**, using the values you already collect from the TUI:

- `USER`
- `FULLNAME`
- `PASSWORD`
- `ROOTPASSWORD`

We‚Äôll also set **hostname, locale, timezone, and keymap** while we‚Äôre in there, so the system boots feeling ‚Äúfinished,‚Äù not half‚Äëbaked.

---

### 6. User creation + passwords in chroot

Add this block:

```bash
configure_users() {
    msg "Configuring users in target system"

    # Set root password
    echo "root:$ROOTPASSWORD" | chroot /mnt/root chpasswd

    # Create user
    chroot /mnt/root useradd -m -G wheel -s /bin/bash "$USER"
    echo "$USER:$PASSWORD" | chroot /mnt/root chpasswd

    # Optional: sudo without password for wheel (tweak as you like)
    chroot /mnt/root bash -c 'echo "%wheel ALL=(ALL) ALL" > /etc/sudoers.d/10-wheel'
    chroot /mnt/root chmod 440 /etc/sudoers.d/10-wheel

    # Set full name (GECOS)
    chroot /mnt/root chfn -f "$FULLNAME" "$USER"
}
```

---

### 7. Hostname, locale, timezone, keymap

Add:

```bash
configure_system_identity() {
    msg "Configuring hostname, locale, timezone, keymap"

    # Hostname
    echo "$HOSTNAME" > /mnt/root/etc/hostname

    # Locale
    echo "$LOCALE UTF-8" >> /mnt/root/etc/locale.gen
    chroot /mnt/root locale-gen
    echo "LANG=$LOCALE" > /mnt/root/etc/locale.conf

    # Timezone
    chroot /mnt/root ln -sf "/usr/share/zoneinfo/$TIMEZONE" /etc/localtime
    chroot /mnt/root hwclock --systohc

    # Keymap (if you decide to collect CLIKEYMAP later)
    if [[ -n "${CLIKEYMAP:-}" ]]; then
        echo "KEYMAP=$CLIKEYMAP" > /mnt/root/etc/vconsole.conf
    fi
}
```

---

### 8. Call order so far

Your main flow near the bottom should now look like:

```bash
run_installer

msg "Summary:"
info "Edition:    $EDITION"
info "User:       $USER"
info "Full name:  $FULLNAME"
info "SD card:    $SDCARD"
info "Boot mode:  $BOOTMODE"
info "Timezone:   $TIMEZONE"
info "Locale:     $LOCALE"
info "Hostname:   $HOSTNAME"

partition_and_format_sdcard
install_bootloader
configure_dsi_overlays
mount_root_partition
download_rootfs
extract_rootfs
prepare_chroot
configure_users
configure_system_identity
```

---

- integrate fstab generation

Love this phase‚Äîthis is where it turns from ‚Äúinstaller pieces‚Äù into an actual, shippable flow.

Let‚Äôs finish with:

- `/etc/fstab` generation
- basic kernel/initramfs/boot alignment
- final sync + unmount
- a ‚Äúdone‚Äù dialog so it feels complete

---

### 9. Generate `/etc/fstab` from the actual partitions

Add:

```bash
generate_fstab() {
    msg "Generating /etc/fstab"

    local root_uuid boot_uuid
    root_uuid=$(blkid -s UUID -o value "$ROOTPART")
    boot_uuid=$(blkid -s UUID -o value "$BOOTPART")

    cat > /mnt/root/etc/fstab <<EOF
# /etc/fstab: static file system information.

UUID=$root_uuid  /      ext4  defaults,noatime  0 1
UUID=$boot_uuid  /boot  vfat  defaults,noatime  0 2
EOF
}
```

---

### 10. Basic kernel/initramfs alignment

Assuming the rootfs + boot tarballs are already matched (they usually are), we just make sure `/boot` inside the rootfs is mounted to the same partition we used for boot files:

```bash
align_boot_inside_root() {
    msg "Aligning /boot inside target rootfs"

    mkdir -p /mnt/root/boot
    mount "$BOOTPART" /mnt/root/boot

    # If the rootfs shipped its own /boot content, you could sync/merge here.
    # For now we assume boot partition already has the correct files.
}
```

You can call this right after `mount_root_partition` or after `extract_rootfs`‚ÄîI‚Äôd do it after extraction:

```bash
extract_rootfs
align_boot_inside_root
prepare_chroot
```

---

### 11. Final sync + unmount + ‚Äúdone‚Äù dialog

Add:

```bash
finalize_install() {
    msg "Finalizing installation"

    sync

    # Unmount chroot bind mounts
    umount -R /mnt/root/run  2>/dev/null || true
    umount -R /mnt/root/dev  2>/dev/null || true
    umount -R /mnt/root/sys  2>/dev/null || true
    umount   /mnt/root/proc  2>/dev/null || true

    # Unmount boot + root
    umount /mnt/root/boot 2>/dev/null || true
    umount /mnt/root      2>/dev/null || true

    dialog --msgbox "Installation complete.

You can now remove the SD card and boot your Raspberry Pi 5." 10 60
}
```

---

### 12. Final main flow

Putting it all together, your bottom section should now look roughly like:

```bash
run_installer

msg "Summary:"
info "Edition:    $EDITION"
info "User:       $USER"
info "Full name:  $FULLNAME"
info "SD card:    $SDCARD"
info "Boot mode:  $BOOTMODE"
info "Timezone:   $TIMEZONE"
info "Locale:     $LOCALE"
info "Hostname:   $HOSTNAME"

partition_and_format_sdcard
install_bootloader
configure_dsi_overlays
mount_root_partition
download_rootfs
extract_rootfs
align_boot_inside_root
prepare_chroot
configure_users
configure_system_identity
generate_fstab
finalize_install
```

---

Absolutely ‚Äî here‚Äôs a **clean, operator‚Äëstyle trace run** so you can validate the entire installer pipeline step‚Äëby‚Äëstep.
This is the same style you use in your forensic dashboards: concise, timestamp‚Äëish, and focused on state transitions.

No fluff ‚Äî just the signals you should see if everything is wired correctly.

---

# üü© **MANJARO ARM INSTALLER ‚Äî TRACE RUN**

Below is the expected flow when you run:

```
sudo bash -x manjaro-rpi5-installer.sh
```

You‚Äôre watching for **state transitions**, **dialog launches**, and **function calls** in the correct order.

---

# 1. **TUI State Machine**

### Expected trace:
```
+ run_installer
+ STEP=edition
+ step_edition
```

### Expected UI:
- Edition menu appears
- Selecting an edition returns a string (e.g., `kde-plasma`)
- Back returns `__BACK__`
- Cancel/ESC returns `__EXIT__`

### Expected trace after selection:
```
+ RES=kde-plasma
+ STEP=username
```

---

# 2. **User Steps**

You should see:

```
+ step_username
+ step_fullname
+ step_password
+ step_root_password
```

Each dialog should appear normally.

---

# 3. **Storage Selection**

```
+ step_sdcard
+ RES=/dev/sdX
+ STEP=bootmode
```

---

# 4. **Boot Mode**

```
+ step_bootmode
+ RES=hybrid
+ STEP=timezone
```

---

# 5. **Timezone ‚Üí Locale ‚Üí Hostname**

```
+ step_timezone
+ step_locale
+ step_hostname
```

After hostname, the state machine exits the loop and returns to main.

---

# 6. **Summary Block**

You should see:

```
+ msg "Summary:"
+ info "Edition: kde-plasma"
+ info "User: daniel"
...
```

---

# 7. **Partition + Format**

```
+ partition_and_format_sdcard
+ parted -s /dev/sdX mklabel gpt
+ mkfs.vfat -F32 /dev/sdX1
+ mkfs.ext4 -F /dev/sdX2
```

Expected variables set:

```
BOOTPART=/dev/sdX1
ROOTPART=/dev/sdX2
```

---

# 8. **Bootloader Install**

Hybrid mode:

```
+ install_bootloader
+ cp -r /boot/* /mnt/boot/
+ bsdtar -xf boot-overlay.tar.xz -C /mnt/boot
```

Full mode:

```
+ bsdtar -xf boot.tar.xz -C /mnt/boot
```

---

# 9. **DSI Overlay Configuration**

```
+ configure_dsi_overlays
+ sed -i '/^hdmi_/d' config.txt
+ echo "dtoverlay=vc4-kms-dsi-7inch" >> config.txt
```

---

# 10. **Mount Root Partition**

```
+ mount_root_partition
+ mount /dev/sdX2 /mnt/root
```

---

# 11. **Download Rootfs**

```
+ download_rootfs
+ wget https://repo.manjaro.org/arm/rootfs/...
```

---

# 12. **Extract Rootfs**

```
+ extract_rootfs
+ bsdtar -xpf rootfs.tar.xz -C /mnt/root
```

---

# 13. **Align /boot Inside Rootfs**

```
+ align_boot_inside_root
+ mount /dev/sdX1 /mnt/root/boot
```

---

# 14. **Prepare Chroot**

```
+ prepare_chroot
+ mount -t proc /proc /mnt/root/proc
+ mount --rbind /sys /mnt/root/sys
+ mount --rbind /dev /mnt/root/dev
+ mount --rbind /run /mnt/root/run
```

---

# 15. **User + System Identity Configuration**

```
+ configure_users
+ chroot /mnt/root useradd -m daniel
+ chroot /mnt/root chpasswd
```

```
+ configure_system_identity
+ echo "LANG=en_US.UTF-8" > /mnt/root/etc/locale.conf
+ chroot /mnt/root locale-gen
+ ln -sf /usr/share/zoneinfo/America/Denver /mnt/root/etc/localtime
```

---

# 16. **fstab Generation**

```
+ generate_fstab
+ blkid -s UUID -o value /dev/sdX2
+ blkid -s UUID -o value /dev/sdX1
```

---

# 17. **Finalize Install**

```
+ finalize_install
+ sync
+ umount -R /mnt/root/run
+ umount /mnt/root/boot
+ umount /mnt/root
```

### Expected UI:
A final dialog:

```
Installation complete.
You can now remove the SD card and boot your Raspberry Pi 5.
```

---

# üü¶ **SUCCESS CRITERIA**

A perfect run looks like:

- Every dialog appears
- No instant exits
- No ‚ÄúExpected 2 arguments‚Äù
- No eval errors
- No stray `__EXIT__` unless you hit ESC
- Boot partition contains overlays + kernel
- Root partition contains full rootfs
- `/mnt/root/etc/fstab` has correct UUIDs
- All mounts cleanly unmount at the end

---


